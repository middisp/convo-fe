import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, e as element, a as space, t as text, c as claim_element, h as claim_space, b as children, f as claim_text, g as detach_dev, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, o as listen_dev, p as set_data_dev, r as noop, N as validate_store, O as component_subscribe, I as user, L as token, x as binding_callbacks, y as bind, z as create_component, A as claim_component, B as mount_component, D as transition_in, E as transition_out, H as check_outros, C as add_flush_callback, F as destroy_component, P as empty, G as query_selector_all, M as group_outros } from './client.104c6a62.js';
import { I as Input, B as Button, U as UserMessage } from './UserMessage.0f647b6c.js';

/* src\components\Toggle.svelte generated by Svelte v3.18.1 */

const file = "src\\components\\Toggle.svelte";

function create_fragment(ctx) {
	let input;
	let t0;
	let label;
	let t1;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			label = element("label");
			t1 = text(/*labelText*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				name: true,
				id: true,
				type: true,
				class: true
			});

			t0 = claim_space(nodes);
			label = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_nodes = children(label);
			t1 = claim_text(label_nodes, /*labelText*/ ctx[2]);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "name", /*name*/ ctx[1]);
			attr_dev(input, "id", /*name*/ ctx[1]);
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "class", "svelte-1g1xjfv");
			add_location(input, file, 61, 0, 1109);
			attr_dev(label, "for", /*name*/ ctx[1]);
			attr_dev(label, "class", "svelte-1g1xjfv");
			add_location(label, file, 62, 0, 1174);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			input.checked = /*value*/ ctx[0];
			insert_dev(target, t0, anchor);
			insert_dev(target, label, anchor);
			append_dev(label, t1);
			dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[3]);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*name*/ 2) {
				attr_dev(input, "name", /*name*/ ctx[1]);
			}

			if (dirty & /*name*/ 2) {
				attr_dev(input, "id", /*name*/ ctx[1]);
			}

			if (dirty & /*value*/ 1) {
				input.checked = /*value*/ ctx[0];
			}

			if (dirty & /*labelText*/ 4) set_data_dev(t1, /*labelText*/ ctx[2]);

			if (dirty & /*name*/ 2) {
				attr_dev(label, "for", /*name*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(label);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { name } = $$props;
	let { labelText } = $$props;
	let { value = false } = $$props;
	const writable_props = ["name", "labelText", "value"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Toggle> was created with unknown prop '${key}'`);
	});

	function input_change_handler() {
		value = this.checked;
		$$invalidate(0, value);
	}

	$$self.$set = $$props => {
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("labelText" in $$props) $$invalidate(2, labelText = $$props.labelText);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
	};

	$$self.$capture_state = () => {
		return { name, labelText, value };
	};

	$$self.$inject_state = $$props => {
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("labelText" in $$props) $$invalidate(2, labelText = $$props.labelText);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
	};

	return [value, name, labelText, input_change_handler];
}

class Toggle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { name: 1, labelText: 2, value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toggle",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<Toggle> was created without expected prop 'name'");
		}

		if (/*labelText*/ ctx[2] === undefined && !("labelText" in props)) {
			console.warn("<Toggle> was created without expected prop 'labelText'");
		}
	}

	get name() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelText() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelText(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\profile.svelte generated by Svelte v3.18.1 */
const file$1 = "src\\routes\\profile.svelte";

// (100:0) {#if $user}
function create_if_block(ctx) {
	let t0;
	let form0;
	let img;
	let img_src_value;
	let img_alt_value;
	let t1;
	let updating_value;
	let t2;
	let updating_value_1;
	let t3;
	let updating_value_2;
	let t4;
	let updating_value_3;
	let t5;
	let updating_value_4;
	let t6;
	let t7;
	let form1;
	let legend;
	let t8;
	let t9;
	let updating_value_5;
	let t10;
	let updating_value_6;
	let t11;
	let updating_value_7;
	let t12;
	let current;
	let if_block0 = /*alert*/ ctx[4] && create_if_block_2(ctx);

	function toggle_value_binding(value) {
		/*toggle_value_binding*/ ctx[11].call(null, value);
	}

	let toggle_props = { name: "edit", labelText: "Edit" };

	if (/*isEditable*/ ctx[0] !== void 0) {
		toggle_props.value = /*isEditable*/ ctx[0];
	}

	const toggle = new Toggle({ props: toggle_props, $$inline: true });
	binding_callbacks.push(() => bind(toggle, "value", toggle_value_binding));

	function input0_value_binding(value_1) {
		/*input0_value_binding*/ ctx[12].call(null, value_1);
	}

	let input0_props = {
		type: "text",
		name: "firstName",
		labelText: "First Name",
		disabled: !/*isEditable*/ ctx[0],
		required: false
	};

	if (/*updatedUser*/ ctx[5].firstName !== void 0) {
		input0_props.value = /*updatedUser*/ ctx[5].firstName;
	}

	const input0 = new Input({ props: input0_props, $$inline: true });
	binding_callbacks.push(() => bind(input0, "value", input0_value_binding));

	function input1_value_binding(value_2) {
		/*input1_value_binding*/ ctx[13].call(null, value_2);
	}

	let input1_props = {
		type: "text",
		name: "lastName",
		labelText: "Last Name",
		disabled: !/*isEditable*/ ctx[0],
		required: false
	};

	if (/*updatedUser*/ ctx[5].lastName !== void 0) {
		input1_props.value = /*updatedUser*/ ctx[5].lastName;
	}

	const input1 = new Input({ props: input1_props, $$inline: true });
	binding_callbacks.push(() => bind(input1, "value", input1_value_binding));

	function input2_value_binding(value_3) {
		/*input2_value_binding*/ ctx[14].call(null, value_3);
	}

	let input2_props = {
		type: "text",
		name: "displayName",
		labelText: "Display Name",
		disabled: !/*isEditable*/ ctx[0],
		required: false
	};

	if (/*updatedUser*/ ctx[5].displayName !== void 0) {
		input2_props.value = /*updatedUser*/ ctx[5].displayName;
	}

	const input2 = new Input({ props: input2_props, $$inline: true });
	binding_callbacks.push(() => bind(input2, "value", input2_value_binding));

	function input3_value_binding(value_4) {
		/*input3_value_binding*/ ctx[15].call(null, value_4);
	}

	let input3_props = {
		type: "email",
		name: "email",
		labelText: "Email",
		disabled: !/*isEditable*/ ctx[0],
		required: false
	};

	if (/*updatedUser*/ ctx[5].email !== void 0) {
		input3_props.value = /*updatedUser*/ ctx[5].email;
	}

	const input3 = new Input({ props: input3_props, $$inline: true });
	binding_callbacks.push(() => bind(input3, "value", input3_value_binding));
	let if_block1 = /*isEditable*/ ctx[0] && create_if_block_1(ctx);

	function input4_value_binding(value_5) {
		/*input4_value_binding*/ ctx[16].call(null, value_5);
	}

	let input4_props = {
		type: "password",
		name: "password",
		labelText: "Current Password",
		required: true
	};

	if (/*currentPassword*/ ctx[1] !== void 0) {
		input4_props.value = /*currentPassword*/ ctx[1];
	}

	const input4 = new Input({ props: input4_props, $$inline: true });
	binding_callbacks.push(() => bind(input4, "value", input4_value_binding));

	function input5_value_binding(value_6) {
		/*input5_value_binding*/ ctx[17].call(null, value_6);
	}

	let input5_props = {
		type: "password",
		name: "new-password",
		labelText: "New Password",
		required: true
	};

	if (/*newPassword*/ ctx[2] !== void 0) {
		input5_props.value = /*newPassword*/ ctx[2];
	}

	const input5 = new Input({ props: input5_props, $$inline: true });
	binding_callbacks.push(() => bind(input5, "value", input5_value_binding));

	function input6_value_binding(value_7) {
		/*input6_value_binding*/ ctx[18].call(null, value_7);
	}

	let input6_props = {
		type: "password",
		name: "c-password",
		labelText: "Confirm New Password",
		required: true
	};

	if (/*confNewPassword*/ ctx[3] !== void 0) {
		input6_props.value = /*confNewPassword*/ ctx[3];
	}

	const input6 = new Input({ props: input6_props, $$inline: true });
	binding_callbacks.push(() => bind(input6, "value", input6_value_binding));

	const button = new Button({
			props: {
				type: "submit",
				klass: "primary",
				text: "Save"
			},
			$$inline: true
		});

	button.$on("click", /*updatePassword*/ ctx[8]);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			form0 = element("form");
			img = element("img");
			t1 = space();
			create_component(toggle.$$.fragment);
			t2 = space();
			create_component(input0.$$.fragment);
			t3 = space();
			create_component(input1.$$.fragment);
			t4 = space();
			create_component(input2.$$.fragment);
			t5 = space();
			create_component(input3.$$.fragment);
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			form1 = element("form");
			legend = element("legend");
			t8 = text("Password management");
			t9 = space();
			create_component(input4.$$.fragment);
			t10 = space();
			create_component(input5.$$.fragment);
			t11 = space();
			create_component(input6.$$.fragment);
			t12 = space();
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			form0 = claim_element(nodes, "FORM", { class: true });
			var form0_nodes = children(form0);
			img = claim_element(form0_nodes, "IMG", { src: true, alt: true, class: true });
			t1 = claim_space(form0_nodes);
			claim_component(toggle.$$.fragment, form0_nodes);
			t2 = claim_space(form0_nodes);
			claim_component(input0.$$.fragment, form0_nodes);
			t3 = claim_space(form0_nodes);
			claim_component(input1.$$.fragment, form0_nodes);
			t4 = claim_space(form0_nodes);
			claim_component(input2.$$.fragment, form0_nodes);
			t5 = claim_space(form0_nodes);
			claim_component(input3.$$.fragment, form0_nodes);
			t6 = claim_space(form0_nodes);
			if (if_block1) if_block1.l(form0_nodes);
			form0_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			form1 = claim_element(nodes, "FORM", { class: true });
			var form1_nodes = children(form1);
			legend = claim_element(form1_nodes, "LEGEND", {});
			var legend_nodes = children(legend);
			t8 = claim_text(legend_nodes, "Password management");
			legend_nodes.forEach(detach_dev);
			t9 = claim_space(form1_nodes);
			claim_component(input4.$$.fragment, form1_nodes);
			t10 = claim_space(form1_nodes);
			claim_component(input5.$$.fragment, form1_nodes);
			t11 = claim_space(form1_nodes);
			claim_component(input6.$$.fragment, form1_nodes);
			t12 = claim_space(form1_nodes);
			claim_component(button.$$.fragment, form1_nodes);
			form1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "/images/default-avatar.png")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = `${/*updatedUser*/ ctx[5].firstName} ${/*updatedUser*/ ctx[5].lastName}`);
			attr_dev(img, "class", "svelte-1v6aass");
			add_location(img, file$1, 104, 4, 2776);
			attr_dev(form0, "class", "userDetails svelte-1v6aass");
			add_location(form0, file$1, 103, 2, 2744);
			add_location(legend, file$1, 147, 4, 3858);
			attr_dev(form1, "class", "passwordManagement svelte-1v6aass");
			add_location(form1, file$1, 146, 2, 3819);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, form0, anchor);
			append_dev(form0, img);
			append_dev(form0, t1);
			mount_component(toggle, form0, null);
			append_dev(form0, t2);
			mount_component(input0, form0, null);
			append_dev(form0, t3);
			mount_component(input1, form0, null);
			append_dev(form0, t4);
			mount_component(input2, form0, null);
			append_dev(form0, t5);
			mount_component(input3, form0, null);
			append_dev(form0, t6);
			if (if_block1) if_block1.m(form0, null);
			insert_dev(target, t7, anchor);
			insert_dev(target, form1, anchor);
			append_dev(form1, legend);
			append_dev(legend, t8);
			append_dev(form1, t9);
			mount_component(input4, form1, null);
			append_dev(form1, t10);
			mount_component(input5, form1, null);
			append_dev(form1, t11);
			mount_component(input6, form1, null);
			append_dev(form1, t12);
			mount_component(button, form1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*alert*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*updatedUser*/ 32 && img_alt_value !== (img_alt_value = `${/*updatedUser*/ ctx[5].firstName} ${/*updatedUser*/ ctx[5].lastName}`)) {
				attr_dev(img, "alt", img_alt_value);
			}

			const toggle_changes = {};

			if (!updating_value && dirty & /*isEditable*/ 1) {
				updating_value = true;
				toggle_changes.value = /*isEditable*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			toggle.$set(toggle_changes);
			const input0_changes = {};
			if (dirty & /*isEditable*/ 1) input0_changes.disabled = !/*isEditable*/ ctx[0];

			if (!updating_value_1 && dirty & /*updatedUser*/ 32) {
				updating_value_1 = true;
				input0_changes.value = /*updatedUser*/ ctx[5].firstName;
				add_flush_callback(() => updating_value_1 = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};
			if (dirty & /*isEditable*/ 1) input1_changes.disabled = !/*isEditable*/ ctx[0];

			if (!updating_value_2 && dirty & /*updatedUser*/ 32) {
				updating_value_2 = true;
				input1_changes.value = /*updatedUser*/ ctx[5].lastName;
				add_flush_callback(() => updating_value_2 = false);
			}

			input1.$set(input1_changes);
			const input2_changes = {};
			if (dirty & /*isEditable*/ 1) input2_changes.disabled = !/*isEditable*/ ctx[0];

			if (!updating_value_3 && dirty & /*updatedUser*/ 32) {
				updating_value_3 = true;
				input2_changes.value = /*updatedUser*/ ctx[5].displayName;
				add_flush_callback(() => updating_value_3 = false);
			}

			input2.$set(input2_changes);
			const input3_changes = {};
			if (dirty & /*isEditable*/ 1) input3_changes.disabled = !/*isEditable*/ ctx[0];

			if (!updating_value_4 && dirty & /*updatedUser*/ 32) {
				updating_value_4 = true;
				input3_changes.value = /*updatedUser*/ ctx[5].email;
				add_flush_callback(() => updating_value_4 = false);
			}

			input3.$set(input3_changes);

			if (/*isEditable*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(form0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const input4_changes = {};

			if (!updating_value_5 && dirty & /*currentPassword*/ 2) {
				updating_value_5 = true;
				input4_changes.value = /*currentPassword*/ ctx[1];
				add_flush_callback(() => updating_value_5 = false);
			}

			input4.$set(input4_changes);
			const input5_changes = {};

			if (!updating_value_6 && dirty & /*newPassword*/ 4) {
				updating_value_6 = true;
				input5_changes.value = /*newPassword*/ ctx[2];
				add_flush_callback(() => updating_value_6 = false);
			}

			input5.$set(input5_changes);
			const input6_changes = {};

			if (!updating_value_7 && dirty & /*confNewPassword*/ 8) {
				updating_value_7 = true;
				input6_changes.value = /*confNewPassword*/ ctx[3];
				add_flush_callback(() => updating_value_7 = false);
			}

			input6.$set(input6_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(toggle.$$.fragment, local);
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(input2.$$.fragment, local);
			transition_in(input3.$$.fragment, local);
			transition_in(if_block1);
			transition_in(input4.$$.fragment, local);
			transition_in(input5.$$.fragment, local);
			transition_in(input6.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(toggle.$$.fragment, local);
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(input2.$$.fragment, local);
			transition_out(input3.$$.fragment, local);
			transition_out(if_block1);
			transition_out(input4.$$.fragment, local);
			transition_out(input5.$$.fragment, local);
			transition_out(input6.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(form0);
			destroy_component(toggle);
			destroy_component(input0);
			destroy_component(input1);
			destroy_component(input2);
			destroy_component(input3);
			if (if_block1) if_block1.d();
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(form1);
			destroy_component(input4);
			destroy_component(input5);
			destroy_component(input6);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(100:0) {#if $user}",
		ctx
	});

	return block;
}

// (101:2) {#if alert}
function create_if_block_2(ctx) {
	let updating_alert;
	let current;

	function usermessage_alert_binding(value) {
		/*usermessage_alert_binding*/ ctx[10].call(null, value);
	}

	let usermessage_props = {};

	if (/*alert*/ ctx[4] !== void 0) {
		usermessage_props.alert = /*alert*/ ctx[4];
	}

	const usermessage = new UserMessage({ props: usermessage_props, $$inline: true });
	binding_callbacks.push(() => bind(usermessage, "alert", usermessage_alert_binding));

	const block = {
		c: function create() {
			create_component(usermessage.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(usermessage.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(usermessage, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const usermessage_changes = {};

			if (!updating_alert && dirty & /*alert*/ 16) {
				updating_alert = true;
				usermessage_changes.alert = /*alert*/ ctx[4];
				add_flush_callback(() => updating_alert = false);
			}

			usermessage.$set(usermessage_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(usermessage.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(usermessage.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(usermessage, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(101:2) {#if alert}",
		ctx
	});

	return block;
}

// (142:4) {#if isEditable}
function create_if_block_1(ctx) {
	let current;

	const button = new Button({
			props: {
				type: "submit",
				klass: "primary",
				text: "Save"
			},
			$$inline: true
		});

	button.$on("click", /*save*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(142:4) {#if isEditable}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let title_value;
	let t;
	let if_block_anchor;
	let current;
	document.title = title_value = "Convo - $" + /*$user*/ ctx[6].firstName;
	let if_block = /*$user*/ ctx[6] && create_if_block(ctx);

	const block = {
		c: function create() {
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-5ov8dn\"]", document.head);
			head_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*$user*/ 64) && title_value !== (title_value = "Convo - $" + /*$user*/ ctx[6].firstName)) {
				document.title = title_value;
			}

			if (/*$user*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $user;
	let $token;
	validate_store(user, "user");
	component_subscribe($$self, user, $$value => $$invalidate(6, $user = $$value));
	validate_store(token, "token");
	component_subscribe($$self, token, $$value => $$invalidate(9, $token = $$value));
	let isEditable;
	let currentPassword = "";
	let newPassword = "";
	let confNewPassword = "";
	let alert;
	let updatedUser = $user;

	const save = () => {
		fetch(`http://localhost:3000/user/update/${updatedUser._id}`, {
			method: "put",
			headers: {
				"Content-Type": "application/json",
				Authorization: `bearer: ${$token}`
			},
			body: JSON.stringify(updatedUser)
		}).then(res => res.json()).then(result => {
			if (result.statusCode) {
				$$invalidate(4, alert = { message: result.message, type: "error" });
			}

			user.update(result => result);

			$$invalidate(4, alert = {
				message: "Update successful",
				type: "success"
			});
		}).catch(e => {
			$$invalidate(4, alert = { message: e, type: "error" });
			console.log(e);
		});
	};

	const updatePassword = () => {
		if (!currentPassword || !newPassword || !confNewPassword) {
			return $$invalidate(4, alert = {
				message: "Please provide passwords",
				type: "error"
			});
		}

		if (newPassword !== confNewPassword) {
			return error = {
				message: "Passwords don't match",
				type: "error"
			};
		}

		fetch(`http://localhost:3000/login/updatePassword/${$user._id}`, {
			method: "put",
			headers: {
				"Content-Type": "application/json",
				Authorization: `bearer: ${$token}`
			},
			body: JSON.stringify({ currentPassword, newPassword })
		}).then(res => res.json()).then(result => {
			if (result.statusCode) {
				$$invalidate(4, alert = { message: result.message, type: "error" });
			}

			user.update(result => result);

			$$invalidate(4, alert = {
				message: "Update successful",
				type: "success"
			});
		}).catch(e => {
			$$invalidate(4, alert = { message: e, type: "error" });
			console.log(e);
		});
	};

	function usermessage_alert_binding(value) {
		alert = value;
		$$invalidate(4, alert);
	}

	function toggle_value_binding(value) {
		isEditable = value;
		$$invalidate(0, isEditable);
	}

	function input0_value_binding(value_1) {
		updatedUser.firstName = value_1;
		$$invalidate(5, updatedUser);
	}

	function input1_value_binding(value_2) {
		updatedUser.lastName = value_2;
		$$invalidate(5, updatedUser);
	}

	function input2_value_binding(value_3) {
		updatedUser.displayName = value_3;
		$$invalidate(5, updatedUser);
	}

	function input3_value_binding(value_4) {
		updatedUser.email = value_4;
		$$invalidate(5, updatedUser);
	}

	function input4_value_binding(value_5) {
		currentPassword = value_5;
		$$invalidate(1, currentPassword);
	}

	function input5_value_binding(value_6) {
		newPassword = value_6;
		$$invalidate(2, newPassword);
	}

	function input6_value_binding(value_7) {
		confNewPassword = value_7;
		$$invalidate(3, confNewPassword);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("isEditable" in $$props) $$invalidate(0, isEditable = $$props.isEditable);
		if ("currentPassword" in $$props) $$invalidate(1, currentPassword = $$props.currentPassword);
		if ("newPassword" in $$props) $$invalidate(2, newPassword = $$props.newPassword);
		if ("confNewPassword" in $$props) $$invalidate(3, confNewPassword = $$props.confNewPassword);
		if ("alert" in $$props) $$invalidate(4, alert = $$props.alert);
		if ("updatedUser" in $$props) $$invalidate(5, updatedUser = $$props.updatedUser);
		if ("$user" in $$props) user.set($user = $$props.$user);
		if ("$token" in $$props) token.set($token = $$props.$token);
	};

	return [
		isEditable,
		currentPassword,
		newPassword,
		confNewPassword,
		alert,
		updatedUser,
		$user,
		save,
		updatePassword,
		$token,
		usermessage_alert_binding,
		toggle_value_binding,
		input0_value_binding,
		input1_value_binding,
		input2_value_binding,
		input3_value_binding,
		input4_value_binding,
		input5_value_binding,
		input6_value_binding
	];
}

class Profile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Profile",
			options,
			id: create_fragment$1.name
		});
	}
}

export default Profile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZmlsZS40OTRiOGViOS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVG9nZ2xlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvcHJvZmlsZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cclxuICBleHBvcnQgbGV0IG5hbWU7XHJcbiAgZXhwb3J0IGxldCBsYWJlbFRleHQ7XHJcbiAgZXhwb3J0IGxldCB2YWx1ZSA9IGZhbHNlO1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuICBpbnB1dCB7XHJcbiAgICBib3JkZXI6IDA7XHJcbiAgICBjbGlwOiByZWN0KDAgMCAwIDApO1xyXG4gICAgaGVpZ2h0OiAxcHg7XHJcbiAgICBtYXJnaW46IC0xcHg7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgcGFkZGluZzogMDtcclxuICAgIHdpZHRoOiAxcHg7XHJcbiAgfVxyXG5cclxuICBsYWJlbCB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gIH1cclxuXHJcbiAgbGFiZWw6YmVmb3JlLFxyXG4gIGxhYmVsOmFmdGVyIHtcclxuICAgIGNvbnRlbnQ6IFwiXCI7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICAgIHRvcDogMDtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHJpZ2h0OiAwO1xyXG4gICAgdG9wOiA1MCU7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XHJcbiAgfVxyXG5cclxuICBsYWJlbDpiZWZvcmUge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYm9keUJHQ29sb3IpO1xyXG4gICAgYm9yZGVyOiBzb2xpZCAxcHggdmFyKC0tYm9yZGVyQ29sb3IpO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMTVweDtcclxuICAgIGhlaWdodDogMzBweDtcclxuICAgIHdpZHRoOiA2MHB4O1xyXG4gIH1cclxuXHJcbiAgbGFiZWw6YWZ0ZXIge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2RkZDtcclxuICAgIGJvcmRlcjogc29saWQgMXB4IHZhcigtLWJvcmRlckNvbG9yKTtcclxuICAgIGhlaWdodDogMjVweDtcclxuICAgIHdpZHRoOiAyNXB4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgcmlnaHQ6IDMxcHg7XHJcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4yNXMgZWFzZS1pbjtcclxuICB9XHJcblxyXG4gIGlucHV0OmNoZWNrZWQgKyBsYWJlbDphZnRlciB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zdWNjZXNzKTtcclxuICAgIGJvcmRlcjogc29saWQgMXB4IHZhcigtLXN1Y2Nlc3NEYXJrKTtcclxuICAgIHJpZ2h0OiAzcHg7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG5cclxuPGlucHV0IHtuYW1lfSBpZD17bmFtZX0gdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXt2YWx1ZX0gLz5cclxuPGxhYmVsIGZvcj17bmFtZX0+e2xhYmVsVGV4dH08L2xhYmVsPlxyXG4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCB7IHVzZXIsIHRva2VuIH0gZnJvbSBcIi4uL3N0b3JlLmpzXCI7XHJcblxyXG4gIGltcG9ydCBJbnB1dCBmcm9tIFwiLi4vY29tcG9uZW50cy9JbnB1dC5zdmVsdGVcIjtcclxuICBpbXBvcnQgQnV0dG9uIGZyb20gXCIuLi9jb21wb25lbnRzL0J1dHRvbi5zdmVsdGVcIjtcclxuICBpbXBvcnQgVG9nZ2xlIGZyb20gXCIuLi9jb21wb25lbnRzL1RvZ2dsZS5zdmVsdGVcIjtcclxuICBpbXBvcnQgVXNlck1lc3NhZ2UgZnJvbSBcIi4uL2NvbXBvbmVudHMvVXNlck1lc3NhZ2Uuc3ZlbHRlXCI7XHJcblxyXG4gIGxldCBpc0VkaXRhYmxlO1xyXG4gIGxldCBjdXJyZW50UGFzc3dvcmQgPSBcIlwiO1xyXG4gIGxldCBuZXdQYXNzd29yZCA9IFwiXCI7XHJcbiAgbGV0IGNvbmZOZXdQYXNzd29yZCA9IFwiXCI7XHJcbiAgbGV0IGFsZXJ0O1xyXG4gIGxldCB1cGRhdGVkVXNlciA9ICR1c2VyO1xyXG5cclxuICBjb25zdCBzYXZlID0gKCkgPT4ge1xyXG4gICAgZmV0Y2goYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC91c2VyL3VwZGF0ZS8ke3VwZGF0ZWRVc2VyLl9pZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogXCJwdXRcIixcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBiZWFyZXI6ICR7JHRva2VufWBcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlZFVzZXIpXHJcbiAgICB9KVxyXG4gICAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcclxuICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1c0NvZGUpIHtcclxuICAgICAgICAgIGFsZXJ0ID0geyBtZXNzYWdlOiByZXN1bHQubWVzc2FnZSwgdHlwZTogXCJlcnJvclwiIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVzZXIudXBkYXRlKHJlc3VsdCA9PiByZXN1bHQpO1xyXG4gICAgICAgIGFsZXJ0ID0geyBtZXNzYWdlOiBcIlVwZGF0ZSBzdWNjZXNzZnVsXCIsIHR5cGU6IFwic3VjY2Vzc1wiIH07XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICBhbGVydCA9IHsgbWVzc2FnZTogZSwgdHlwZTogXCJlcnJvclwiIH07XHJcbiAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVwZGF0ZVBhc3N3b3JkID0gKCkgPT4ge1xyXG4gICAgaWYgKCFjdXJyZW50UGFzc3dvcmQgfHwgIW5ld1Bhc3N3b3JkIHx8ICFjb25mTmV3UGFzc3dvcmQpIHtcclxuICAgICAgcmV0dXJuIChhbGVydCA9IHsgbWVzc2FnZTogXCJQbGVhc2UgcHJvdmlkZSBwYXNzd29yZHNcIiwgdHlwZTogXCJlcnJvclwiIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChuZXdQYXNzd29yZCAhPT0gY29uZk5ld1Bhc3N3b3JkKSB7XHJcbiAgICAgIHJldHVybiAoZXJyb3IgPSB7IG1lc3NhZ2U6IFwiUGFzc3dvcmRzIGRvbid0IG1hdGNoXCIsIHR5cGU6IFwiZXJyb3JcIiB9KTtcclxuICAgIH1cclxuICAgIGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjMwMDAvbG9naW4vdXBkYXRlUGFzc3dvcmQvJHskdXNlci5faWR9YCwge1xyXG4gICAgICBtZXRob2Q6IFwicHV0XCIsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICBBdXRob3JpemF0aW9uOiBgYmVhcmVyOiAkeyR0b2tlbn1gXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgY3VycmVudFBhc3N3b3JkLCBuZXdQYXNzd29yZCB9KVxyXG4gICAgfSlcclxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXHJcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlKSB7XHJcbiAgICAgICAgICBhbGVydCA9IHsgbWVzc2FnZTogcmVzdWx0Lm1lc3NhZ2UsIHR5cGU6IFwiZXJyb3JcIiB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB1c2VyLnVwZGF0ZShyZXN1bHQgPT4gcmVzdWx0KTtcclxuICAgICAgICBhbGVydCA9IHsgbWVzc2FnZTogXCJVcGRhdGUgc3VjY2Vzc2Z1bFwiLCB0eXBlOiBcInN1Y2Nlc3NcIiB9O1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgYWxlcnQgPSB7IG1lc3NhZ2U6IGUsIHR5cGU6IFwiZXJyb3JcIiB9O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gICAgICB9KTtcclxuICB9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuICAudXNlckRldGFpbHMge1xyXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcclxuICAgIGJvcmRlcjogc29saWQgMXB4IHZhcigtLWJvcmRlckNvbG9yKTtcclxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICBtYXJnaW4tdG9wOiA4ZW07XHJcbiAgICBwYWRkaW5nOiA2ZW0gMWVtIDFlbTtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICB9XHJcblxyXG4gIC5wYXNzd29yZE1hbmFnZW1lbnQge1xyXG4gICAgbWFyZ2luLXRvcDogMmVtO1xyXG4gIH1cclxuXHJcbiAgaW1nIHtcclxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC41KTtcclxuICAgIG1hcmdpbjogMCBhdXRvO1xyXG4gICAgbGVmdDogNTAlO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiAtMTAwcHg7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XHJcbiAgICBtYXgtd2lkdGg6IDIwMHB4O1xyXG4gIH1cclxuPC9zdHlsZT5cclxuXHJcbjxzdmVsdGU6aGVhZD5cclxuICA8dGl0bGU+Q29udm8gLSAkeyR1c2VyLmZpcnN0TmFtZX08L3RpdGxlPlxyXG48L3N2ZWx0ZTpoZWFkPlxyXG5cclxueyNpZiAkdXNlcn1cclxuICB7I2lmIGFsZXJ0fVxyXG4gICAgPFVzZXJNZXNzYWdlIGJpbmQ6YWxlcnQgLz5cclxuICB7L2lmfVxyXG4gIDxmb3JtIGNsYXNzPVwidXNlckRldGFpbHNcIj5cclxuICAgIDxpbWdcclxuICAgICAgc3JjPVwiL2ltYWdlcy9kZWZhdWx0LWF2YXRhci5wbmdcIlxyXG4gICAgICBhbHQ9e2Ake3VwZGF0ZWRVc2VyLmZpcnN0TmFtZX0gJHt1cGRhdGVkVXNlci5sYXN0TmFtZX1gfSAvPlxyXG4gICAgPFRvZ2dsZSBuYW1lPVwiZWRpdFwiIGxhYmVsVGV4dD1cIkVkaXRcIiBiaW5kOnZhbHVlPXtpc0VkaXRhYmxlfSAvPlxyXG5cclxuICAgIDxJbnB1dFxyXG4gICAgICB0eXBlPVwidGV4dFwiXHJcbiAgICAgIG5hbWU9XCJmaXJzdE5hbWVcIlxyXG4gICAgICBsYWJlbFRleHQ9XCJGaXJzdCBOYW1lXCJcclxuICAgICAgYmluZDp2YWx1ZT17dXBkYXRlZFVzZXIuZmlyc3ROYW1lfVxyXG4gICAgICBkaXNhYmxlZD17IWlzRWRpdGFibGV9XHJcbiAgICAgIHJlcXVpcmVkPXtmYWxzZX0gLz5cclxuXHJcbiAgICA8SW5wdXRcclxuICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICBuYW1lPVwibGFzdE5hbWVcIlxyXG4gICAgICBsYWJlbFRleHQ9XCJMYXN0IE5hbWVcIlxyXG4gICAgICBiaW5kOnZhbHVlPXt1cGRhdGVkVXNlci5sYXN0TmFtZX1cclxuICAgICAgZGlzYWJsZWQ9eyFpc0VkaXRhYmxlfVxyXG4gICAgICByZXF1aXJlZD17ZmFsc2V9IC8+XHJcblxyXG4gICAgPElucHV0XHJcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgbmFtZT1cImRpc3BsYXlOYW1lXCJcclxuICAgICAgbGFiZWxUZXh0PVwiRGlzcGxheSBOYW1lXCJcclxuICAgICAgYmluZDp2YWx1ZT17dXBkYXRlZFVzZXIuZGlzcGxheU5hbWV9XHJcbiAgICAgIGRpc2FibGVkPXshaXNFZGl0YWJsZX1cclxuICAgICAgcmVxdWlyZWQ9e2ZhbHNlfSAvPlxyXG5cclxuICAgIDxJbnB1dFxyXG4gICAgICB0eXBlPVwiZW1haWxcIlxyXG4gICAgICBuYW1lPVwiZW1haWxcIlxyXG4gICAgICBsYWJlbFRleHQ9XCJFbWFpbFwiXHJcbiAgICAgIGJpbmQ6dmFsdWU9e3VwZGF0ZWRVc2VyLmVtYWlsfVxyXG4gICAgICBkaXNhYmxlZD17IWlzRWRpdGFibGV9XHJcbiAgICAgIHJlcXVpcmVkPXtmYWxzZX0gLz5cclxuXHJcbiAgICB7I2lmIGlzRWRpdGFibGV9XHJcbiAgICAgIDxCdXR0b24gdHlwZT1cInN1Ym1pdFwiIG9uOmNsaWNrPXtzYXZlfSBrbGFzcz1cInByaW1hcnlcIiB0ZXh0PVwiU2F2ZVwiIC8+XHJcbiAgICB7L2lmfVxyXG4gIDwvZm9ybT5cclxuXHJcbiAgPGZvcm0gY2xhc3M9XCJwYXNzd29yZE1hbmFnZW1lbnRcIj5cclxuICAgIDxsZWdlbmQ+UGFzc3dvcmQgbWFuYWdlbWVudDwvbGVnZW5kPlxyXG4gICAgPElucHV0XHJcbiAgICAgIHR5cGU9XCJwYXNzd29yZFwiXHJcbiAgICAgIG5hbWU9XCJwYXNzd29yZFwiXHJcbiAgICAgIGxhYmVsVGV4dD1cIkN1cnJlbnQgUGFzc3dvcmRcIlxyXG4gICAgICBiaW5kOnZhbHVlPXtjdXJyZW50UGFzc3dvcmR9XHJcbiAgICAgIHJlcXVpcmVkPXt0cnVlfSAvPlxyXG5cclxuICAgIDxJbnB1dFxyXG4gICAgICB0eXBlPVwicGFzc3dvcmRcIlxyXG4gICAgICBuYW1lPVwibmV3LXBhc3N3b3JkXCJcclxuICAgICAgbGFiZWxUZXh0PVwiTmV3IFBhc3N3b3JkXCJcclxuICAgICAgYmluZDp2YWx1ZT17bmV3UGFzc3dvcmR9XHJcbiAgICAgIHJlcXVpcmVkPXt0cnVlfSAvPlxyXG5cclxuICAgIDxJbnB1dFxyXG4gICAgICB0eXBlPVwicGFzc3dvcmRcIlxyXG4gICAgICBuYW1lPVwiYy1wYXNzd29yZFwiXHJcbiAgICAgIGxhYmVsVGV4dD1cIkNvbmZpcm0gTmV3IFBhc3N3b3JkXCJcclxuICAgICAgYmluZDp2YWx1ZT17Y29uZk5ld1Bhc3N3b3JkfVxyXG4gICAgICByZXF1aXJlZD17dHJ1ZX0gLz5cclxuXHJcbiAgICA8QnV0dG9uXHJcbiAgICAgIHR5cGU9XCJzdWJtaXRcIlxyXG4gICAgICBvbjpjbGljaz17dXBkYXRlUGFzc3dvcmR9XHJcbiAgICAgIGtsYXNzPVwicHJpbWFyeVwiXHJcbiAgICAgIHRleHQ9XCJTYXZlXCIgLz5cclxuICA8L2Zvcm0+XHJcbnsvaWZ9XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQThEbUIsR0FBUzs7Ozs7Ozs7Ozs7Ozs7OENBQVQsR0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0RBQVQsR0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTdEZixJQUFJO09BQ0osU0FBUztPQUNULEtBQUssR0FBRyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQ3dHMkIsR0FBVTtzQ0FBVixHQUFVOzs7Ozs7Ozs7Ozs7Ozs0QkFPOUMsR0FBVTs7OztxQkFEVCxHQUFXLElBQUMsU0FBUzt1Q0FBckIsR0FBVyxJQUFDLFNBQVM7Ozs7Ozs7Ozs7Ozs7OzRCQVN0QixHQUFVOzs7O3FCQURULEdBQVcsSUFBQyxRQUFRO3VDQUFwQixHQUFXLElBQUMsUUFBUTs7Ozs7Ozs7Ozs7Ozs7NEJBU3JCLEdBQVU7Ozs7cUJBRFQsR0FBVyxJQUFDLFdBQVc7dUNBQXZCLEdBQVcsSUFBQyxXQUFXOzs7Ozs7Ozs7Ozs7Ozs0QkFTeEIsR0FBVTs7OztxQkFEVCxHQUFXLElBQUMsS0FBSzt1Q0FBakIsR0FBVyxJQUFDLEtBQUs7Ozs7O2dDQUkxQixHQUFVOzs7Ozs7Ozs7Ozs7O3lCQVdELEdBQWU7MkNBQWYsR0FBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBT2YsR0FBVzt1Q0FBWCxHQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFPWCxH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
